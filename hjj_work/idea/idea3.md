## 通用数据结构幻想

所有战斗都在某个场景

场景存了 n 个怪物编号，n 个场景效果
怪物登场有条件，比如同场怪物数量上限，当前时间、、

为了通用或许也不一定要把场景和怪物参数绑定
这个信息可以做成固定游戏数据，
副本 A 中存储场景信息，怪物信息，掉落物信息，通关后事件编号

副本 A 本身只是一个结构体，是通过这个结构体内部的参数来生成战斗区域和相关内容的

## 为想新技能和写程序的偷懒的设想

技能分被动和主动，之前设想的主要是被动
对于每个主动技能，有着基本的几个要素

-   限制条件
    技能的限制条件有两部分，
    一部分是激活条件，比如在一次攻击间隔结束时才能激活、攻击间隔内持续激活、概率激活、绑定在装备上、某某状态下允许使用、血量高于一定程度、敌人处于攻击范围内等等
    满足了这些条件，这一帧游戏运行的时候，才允许执行这个技能
    另一部分是技能的代价
    使用主动技能之后，消耗某某资源，比如精力，蓝，血，或者背包物品，
    或者技能期间持续消耗，
    或者技能结束之后再支付

-   技能效果的基础
    基于玩家某某属性，计算出主动技能生效之后的具体效果，比如造成的伤害值，增加的防御，
    一般来说主动技能初始是基于一个属性的，也可以基于多个属性，基于红绿蓝资源，基于某被动技能等级
    这块在实际运用中分两部分，玩家基础和补正
    玩家自带有攻击力属性，总不能说某个技能基于力量造成伤害，就无视了攻击力属性吧
    所以玩家基础部分不受技能影响，就算技能没有设置，也该用上
    然后是补正，就是基于玩家属性额外再加成了

-   技能的具体效果
    一般是和技能本身绑定的，就是各个技能各不相同，不然就变成换皮了
    但是有些大类的技能还是不可避免的很相似，
    比如攻击类型的技能，无非就是物理或者魔法或者元素（如果有的话）
    打击近距离|中距离|远距离，或者都打
    打 1 打 n
    造成 1 次伤害，造成 n 次伤害
    辅助类型的，给自己的有临时加成面板属性，临时恢复资源，获得某某 buff
    给敌人的就反过来削弱

一个技能大概就是由激活条件、代价、效果基础、具体效果组成的
为了往游戏里塞更多的技能，想法是让每个技能可以“升级”
比如设计火球术 A，火球术 B，火球术 C
学完都是可以习得火球术这个技能（激活条件共用）
但是对于 A，使用需要消耗 1 蓝，B 需要用 1 个火球符文，C 需要处于 80%精力以上允许使用（多种使用代价）
A 基于灵魂属性造成伤害，B 基于技巧属性造成伤害，C 基于精力属性造成伤害（不同的效果基础，同也没关系，可以增加倍率）
A 对中距离敌人造成伤害，B 对近距离敌人造成高伤害，C 对近距离敌人造成两次伤害

那么如果真的这么设计三个火球技能，这就很换皮，不够有意思，后期也用不到这块代码了，挺浪费的
不如设计一个火球技能，把刚刚提到的要素全都融合进去，根据学到的不同技能，解锁对应的要素

比如开始只学到了 A，那就是一个普通的火球
后来学到了 B，原本的火球就升级了，可以同时基于两种属性来造成伤害，可以同时攻击中近距离敌人，还可以在没蓝的时候使用火球符文代替消耗
再后面学到了 C，又变得更强

技能在一开始设计的时候就设计最强的状态，给玩家用的是加了很多个限制条件的版本
重复学习的过程就是解开各个限制的过程，这个学习顺序可以随意调换，就是各个锁先后解开的区别而已
这样一个主动技能就可以拆成很多个技能书，玩家玩到的时候获取技能书的顺序不同，玩到的感觉也不一样

在这个基础上换皮就高效多了（）
小火球，大火球，巨大火球，只要最终版本的差别大一些，基础版本相似也没关系，
玩家会在变强的过程中使用喜欢的那一种，而且可能后面小火球还比巨大火球更强，再又随着游戏进展而变化

代码会不会很复杂（）
代码真的很复杂（）
至少数值很难设计

想出来的代码实现方案：
最开始设计基础版本
然后设计 n 个它的解锁后的加成
玩家身上存储这个技能的解锁情况
玩家身上存储这个技能解锁之后的汇总详细参数

比如小火球 ABC
开始设计一个小火球，id=little_fire
设计它的基础版本，P_skill["little_fire"]
这里设计了最基础的限制条件，属性补正，索敌逻辑等等（这里可以全填 0）
然后设计小火球 A 解锁加成，id=little_fire_A
base_skill["little_fire_A"]
这里设计了，限制条件需要 1 蓝，基于灵魂属性的属性补正，索敌逻辑是中距离敌人造成伤害
以此类推设计火球 B 和火球 C

然后玩家获得了火球 A 的时候
先检测玩家有无火球，当前是无，所以获取基础版本
然后读取 A 的加成参数，在基础版本上叠加这些参数
这样玩家就拥有了一个基础+A 的技能，呈现出来的效果就是火球 A
当玩家获得火球 B 的时候
读取玩家有无火球，当前有，跳过基础版本获取
然后读取 B 的加成参数，在目前的数据上叠加 B 的参数
这样就得到了 AB 火球

ABC 的获取顺序轮换都行

## buff 系统

### 问题 1：key 的定义

初步设想，是存放在玩家属性对象中的各个对象，每个对象有 id，有时间，有效果
实时更新，删除过期的 buff 对象，添加新对象等等

开发过程中，发现 buff 似乎有点不那么常规
简单来说，如果有两个食物，效果都是通过 buff 回血，食物 A 回血量比较多，那么作为玩家的常规想法，吃掉这俩食物之后有这么几种情况
1：获得两个 buff，分别叫食物 A 和食物 B，buff 同时存在，回血量是两个 buff 的叠加
2：获得食物 A 代表的回血 buff，再因为使用食物 B 获得同样的回血 buff，后一个 buff 覆盖了前一个 buff 的时间和效果等等参数，相当于仅吃了食物 B
3：获得食物 A 代表的回血 buff，吃食物 B 时系统判断这个回血 buff 效果比较弱，就不会覆盖，所以食物 B 没有任何效果

这里选择第一个方案，让玩家利益最大化

### 问题 2：新旧 buff 兼容

然后开发的时候有个情况，如果遇到同 id 的 buff，应该怎么处理
旧 buff 一般是运行了一段时间了，剩余时间较短，新 buff 还是完整的时间
新旧 buff 的效果可能不一样，
如果 buff 一样，就用时间更长的 buff 的时间
如果时间一样，就用 buff 效果更强的效果

纠结的地方在于新 buff 效果更强，但是时间更短应该怎么办，以及反过来，新 buff 效果较弱，但是时间更长

比较通用的解法是不再让程序判断玩家的利益，直接让新 buff 取代旧 buff
开始还想有点小巧思，结果实现不来，算了

### 问题 3：复合属性 buff

开发时遇到了新问题，如果有一个很强的 buff，同时给予了多种属性，那应该怎么开发
目前根据 buff 系统的情况，所有 buff 根据它的时间依据分成了几类
最复杂的情况，这个 buff 同时提供属性加成，提供回血和回精，生效 10 秒/生效 5 回合
想了一下，多复杂的 buff，它的生效时间是对整个 buff 而言的，不应该设计同一个 buff 有几个生效时间
那么复杂的部分就是属性了

1：这一个 buff 就是会提供多种属性
2：这个 buff 实际上是同时给予了多个单一 buff（灵感来自于玩家主动技能）

2 号方案比较难搞的应该是 buff 的 id 问题
当玩家获得了一个 buff，就会在 buff 总对象中添加一个键值对，key 是 buff 的 id
如果使用 2 号方案，就会在 buff 总对象中添加很多个键值对，存放各个子 buffid
而且这些子 buffid 之间完全不能重复，不仅是复杂 buff 内部的子 buffid 不重复，更是不同复杂 buff 内部的子 buffid 都不能重复
否则会出现复杂 buffA 给予了子 buff abcde，复杂 buffB，给予了子 buff afghi
由于出现了同一个 a，在更新和删除时会出现意外情况
