# 程序开发小巧思

## 通用数据结构幻想

所有战斗都在某个场景

场景存了 n 个怪物编号，n 个场景效果
怪物登场有条件，比如同场怪物数量上限，当前时间、、

为了通用或许也不一定要把场景和怪物参数绑定
这个信息可以做成固定游戏数据，
副本 A 中存储场景信息，怪物信息，掉落物信息，通关后事件编号

副本 A 本身只是一个结构体，是通过这个结构体内部的参数来生成战斗区域和相关内容的

## 为想新技能和写程序的偷懒的设想

技能分被动和主动，之前设想的主要是被动
对于每个主动技能，有着基本的几个要素

-   限制条件
    技能的限制条件有两部分，
    一部分是激活条件，比如在一次攻击间隔结束时才能激活、攻击间隔内持续激活、概率激活、绑定在装备上、某某状态下允许使用、血量高于一定程度、敌人处于攻击范围内等等
    满足了这些条件，这一帧游戏运行的时候，才允许执行这个技能
    另一部分是技能的代价
    使用主动技能之后，消耗某某资源，比如精力，蓝，血，或者背包物品，
    或者技能期间持续消耗，
    或者技能结束之后再支付

-   技能效果的基础
    基于玩家某某属性，计算出主动技能生效之后的具体效果，比如造成的伤害值，增加的防御，
    一般来说主动技能初始是基于一个属性的，也可以基于多个属性，基于红绿蓝资源，基于某被动技能等级
    这块在实际运用中分两部分，玩家基础和补正
    玩家自带有攻击力属性，总不能说某个技能基于力量造成伤害，就无视了攻击力属性吧
    所以玩家基础部分不受技能影响，就算技能没有设置，也该用上
    然后是补正，就是基于玩家属性额外再加成了

-   技能的具体效果
    一般是和技能本身绑定的，就是各个技能各不相同，不然就变成换皮了
    但是有些大类的技能还是不可避免的很相似，
    比如攻击类型的技能，无非就是物理或者魔法或者元素（如果有的话）
    打击近距离|中距离|远距离，或者都打
    打 1 打 n
    造成 1 次伤害，造成 n 次伤害
    辅助类型的，给自己的有临时加成面板属性，临时恢复资源，获得某某 buff
    给敌人的就反过来削弱

一个技能大概就是由激活条件、代价、效果基础、具体效果组成的
为了往游戏里塞更多的技能，想法是让每个技能可以“升级”
比如设计火球术 A，火球术 B，火球术 C
学完都是可以习得火球术这个技能（激活条件共用）
但是对于 A，使用需要消耗 1 蓝，B 需要用 1 个火球符文，C 需要处于 80%精力以上允许使用（多种使用代价）
A 基于灵魂属性造成伤害，B 基于技巧属性造成伤害，C 基于精力属性造成伤害（不同的效果基础，同也没关系，可以增加倍率）
A 对中距离敌人造成伤害，B 对近距离敌人造成高伤害，C 对近距离敌人造成两次伤害

那么如果真的这么设计三个火球技能，这就很换皮，不够有意思，后期也用不到这块代码了，挺浪费的
不如设计一个火球技能，把刚刚提到的要素全都融合进去，根据学到的不同技能，解锁对应的要素

比如开始只学到了 A，那就是一个普通的火球
后来学到了 B，原本的火球就升级了，可以同时基于两种属性来造成伤害，可以同时攻击中近距离敌人，还可以在没蓝的时候使用火球符文代替消耗
再后面学到了 C，又变得更强

技能在一开始设计的时候就设计最强的状态，给玩家用的是加了很多个限制条件的版本
重复学习的过程就是解开各个限制的过程，这个学习顺序可以随意调换，就是各个锁先后解开的区别而已
这样一个主动技能就可以拆成很多个技能书，玩家玩到的时候获取技能书的顺序不同，玩到的感觉也不一样

在这个基础上换皮就高效多了（）
小火球，大火球，巨大火球，只要最终版本的差别大一些，基础版本相似也没关系，
玩家会在变强的过程中使用喜欢的那一种，而且可能后面小火球还比巨大火球更强，再又随着游戏进展而变化

代码会不会很复杂（）
代码真的很复杂（）
至少数值很难设计

想出来的代码实现方案：
最开始设计基础版本
然后设计 n 个它的解锁后的加成
玩家身上存储这个技能的解锁情况
玩家身上存储这个技能解锁之后的汇总详细参数

比如小火球 ABC
开始设计一个小火球，id=little_fire
设计它的基础版本，P_skill["little_fire"]
这里设计了最基础的限制条件，属性补正，索敌逻辑等等（这里可以全填 0）
然后设计小火球 A 解锁加成，id=little_fire_A
base_skill["little_fire_A"]
这里设计了，限制条件需要 1 蓝，基于灵魂属性的属性补正，索敌逻辑是中距离敌人造成伤害
以此类推设计火球 B 和火球 C

然后玩家获得了火球 A 的时候
先检测玩家有无火球，当前是无，所以获取基础版本
然后读取 A 的加成参数，在基础版本上叠加这些参数
这样玩家就拥有了一个基础+A 的技能，呈现出来的效果就是火球 A
当玩家获得火球 B 的时候
读取玩家有无火球，当前有，跳过基础版本获取
然后读取 B 的加成参数，在目前的数据上叠加 B 的参数
这样就得到了 AB 火球

ABC 的获取顺序轮换都行

## buff 系统

### 问题 1：key 的定义

初步设想，是存放在玩家属性对象中的各个对象，每个对象有 id，有时间，有效果
实时更新，删除过期的 buff 对象，添加新对象等等

开发过程中，发现 buff 似乎有点不那么常规
简单来说，如果有两个食物，效果都是通过 buff 回血，食物 A 回血量比较多，那么作为玩家的常规想法，吃掉这俩食物之后有这么几种情况
1：获得两个 buff，分别叫食物 A 和食物 B，buff 同时存在，回血量是两个 buff 的叠加
2：获得食物 A 代表的回血 buff，再因为使用食物 B 获得同样的回血 buff，后一个 buff 覆盖了前一个 buff 的时间和效果等等参数，相当于仅吃了食物 B
3：获得食物 A 代表的回血 buff，吃食物 B 时系统判断这个回血 buff 效果比较弱，就不会覆盖，所以食物 B 没有任何效果

这里选择第一个方案，让玩家利益最大化

### 问题 2：新旧 buff 兼容

然后开发的时候有个情况，如果遇到同 id 的 buff，应该怎么处理
旧 buff 一般是运行了一段时间了，剩余时间较短，新 buff 还是完整的时间
新旧 buff 的效果可能不一样，
如果 buff 一样，就用时间更长的 buff 的时间
如果时间一样，就用 buff 效果更强的效果

纠结的地方在于新 buff 效果更强，但是时间更短应该怎么办，以及反过来，新 buff 效果较弱，但是时间更长

比较通用的解法是不再让程序判断玩家的利益，直接让新 buff 取代旧 buff
开始还想有点小巧思，结果实现不来，算了

### 问题 3：复合属性 buff

开发时遇到了新问题，如果有一个很强的 buff，同时给予了多种属性，那应该怎么开发
目前根据 buff 系统的情况，所有 buff 根据它的时间依据分成了几类
最复杂的情况，这个 buff 同时提供属性加成，提供回血和回精，生效 10 秒/生效 5 回合
想了一下，多复杂的 buff，它的生效时间是对整个 buff 而言的，不应该设计同一个 buff 有几个生效时间
那么复杂的部分就是属性了

1：这一个 buff 就是会提供多种属性
2：这个 buff 实际上是同时给予了多个单一 buff（灵感来自于玩家主动技能）

2 号方案比较难搞的应该是 buff 的 id 问题
当玩家获得了一个 buff，就会在 buff 总对象中添加一个键值对，key 是 buff 的 id
如果使用 2 号方案，就会在 buff 总对象中添加很多个键值对，存放各个子 buffid
而且这些子 buffid 之间完全不能重复，不仅是复杂 buff 内部的子 buffid 不重复，更是不同复杂 buff 内部的子 buffid 都不能重复
否则会出现复杂 buffA 给予了子 buff abcde，复杂 buffB，给予了子 buff afghi
由于出现了同一个 a，在更新和删除时会出现意外情况

## 敌人数据库

一个战斗区域里要有几种怪物随机刷新，最简单的例子就是一个高攻低血低防，一个普通，一个低攻高血高防，三个怪随机出现，给玩家一点不同的体验

想要做的更好，那就安排更多种类的怪，十种就是相当多的了
但是细究起来，里面可能有些 boss 怪、宝箱怪、十分少见的稀有怪，白天才刷新的或者晚上才刷新的条件怪
具体到玩的时候，可能还是只有三五种怪当作小兵
不过这已经是比第一层设计要好的了，是普通的正常设计

再想做的更好，那么就要在第二层的基础上，让日常也刷更多怪
但是它们都是小兵，既然在这一个区域里刷新出来，属性就大同小异，并且掉落物也大同小异，甚至都是那么几种，毕竟不能掉落其他地图的东西嘛，假如真的掉了很多不同的掉落物，那除非游戏的物品系统很丰富，否则大量掉落物会影响平衡，只能是掉大量的垃圾，那么影响游戏体验，不如不掉。
那么这个时候，多种小兵在数据库里实际上就只是换了个 id，换了个名字罢了

此时，巧思来了，给最基础的三种怪安排一个“随机名称”的设定，刷怪时随机给个名字，不就很简单的做到了感觉上很多种怪？

这个做法有个问题是图鉴不知道怎么开发
按理来说怪物图鉴就是一个 id 开一条，描述它的情况
如果加入了随机名称，那么随机名称的这种怪，应该怎么设定图鉴呢
1：修改图鉴的逻辑，不按 id 排列，按玩家能看到的随机名称排列
这个方法的问题是排序
多个名字不同属性一样的怪很难避免的并列在一起，看起来就让人觉得，这个游戏作者好敷衍
需要再额外开发一个随机排列功能

2：图鉴依旧按 id 排列，随机名称设定时就和主名称起的差不多，在图鉴里写明随机名称的设定
比如主名称是野猪，那么随机名称就是老野猪胖野猪之类的
图鉴里以野猪开一条图鉴，直说老野猪胖野猪都遵守这个图鉴
这个方法有个问题是并没有很好的起到随机名称造出更多小兵的效果，
玩家都不用进图鉴，刷怪的时候就能直接发现，什么老野猪胖野猪，其实就都是野猪嘛
毕竟如果随机名称写的很乱，那么玩家一看图鉴，野猪的页面下怎么有蛇有树精有牛，看着更怪

随机名称和真正在数据库里新增一个同属性 id 的设计上，还有一个天然的问题
那就是这些随机名称的怪，就真的大同小异了
今天是想偷懒，做了随机名称，后面想用某个名字当作新怪，那还是得给他单开一个敌人对象
针对随机名称的怪属性一样的问题，也可以在刷怪时设定随机属性波动，掉落物也可以随机波动

随机名称这个想法的优点本来是相对于新增敌人拷贝可以少写代码
但是随机名称要做好，得同时有图鉴随机排列代码，初始化属性波动，初始化掉落物波动的代码
可能并没有省下多少
又但是，这个东西做出来以后，确实是可以在不想做新怪的时候偷懒
