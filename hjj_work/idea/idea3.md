## 通用数据结构幻想

所有战斗都在某个场景

场景存了 n 个怪物编号，n 个场景效果
怪物登场有条件，比如同场怪物数量上限，当前时间、、

为了通用或许也不一定要把场景和怪物参数绑定
这个信息可以做成固定游戏数据，
副本 A 中存储场景信息，怪物信息，掉落物信息，通关后事件编号

副本 A 本身只是一个结构体，是通过这个结构体内部的参数来生成战斗区域和相关内容的

## 为想新技能和写程序的偷懒的设想

技能分被动和主动，之前设想的主要是被动
对于每个主动技能，有着基本的几个要素

-   限制条件
    技能的限制条件有两部分，
    一部分是激活条件，比如在一次攻击间隔结束时才能激活、攻击间隔内持续激活、概率激活、绑定在装备上、某某状态下允许使用、血量高于一定程度、敌人处于攻击范围内等等
    满足了这些条件，这一帧游戏运行的时候，才允许执行这个技能
    另一部分是技能的代价
    使用主动技能之后，消耗某某资源，比如精力，蓝，血，或者背包物品，
    或者技能期间持续消耗，
    或者技能结束之后再支付

-   技能效果的基础
    基于玩家某某属性，计算出主动技能生效之后的具体效果，比如造成的伤害值，增加的防御，
    一般来说主动技能初始是基于一个属性的，也可以基于多个属性，基于红绿蓝资源，基于某被动技能等级
    这块在实际运用中分两部分，玩家基础和补正
    玩家自带有攻击力属性，总不能说某个技能基于力量造成伤害，就无视了攻击力属性吧
    所以玩家基础部分不受技能影响，就算技能没有设置，也该用上
    然后是补正，就是基于玩家属性额外再加成了

-   技能的具体效果
    一般是和技能本身绑定的，就是各个技能各不相同，不然就变成换皮了
    但是有些大类的技能还是不可避免的很相似，
    比如攻击类型的技能，无非就是物理或者魔法或者元素（如果有的话）
    打击近距离|中距离|远距离，或者都打
    打 1 打 n
    造成 1 次伤害，造成 n 次伤害
    辅助类型的，给自己的有临时加成面板属性，临时恢复资源，获得某某 buff
    给敌人的就反过来削弱

一个技能大概就是由激活条件、代价、效果基础、具体效果组成的
为了往游戏里塞更多的技能，想法是让每个技能可以“升级”
比如设计火球术 A，火球术 B，火球术 C
学完都是可以习得火球术这个技能（激活条件共用）
但是对于 A，使用需要消耗 1 蓝，B 需要用 1 个火球符文，C 需要处于 80%精力以上允许使用（多种使用代价）
A 基于灵魂属性造成伤害，B 基于技巧属性造成伤害，C 基于精力属性造成伤害（不同的效果基础，同也没关系，可以增加倍率）
A 对中距离敌人造成伤害，B 对近距离敌人造成高伤害，C 对近距离敌人造成两次伤害

那么如果真的这么设计三个火球技能，这就很换皮，不够有意思，后期也用不到这块代码了，挺浪费的
不如设计一个火球技能，把刚刚提到的要素全都融合进去，根据学到的不同技能，解锁对应的要素

比如开始只学到了 A，那就是一个普通的火球
后来学到了 B，原本的火球就升级了，可以同时基于两种属性来造成伤害，可以同时攻击中近距离敌人，还可以在没蓝的时候使用火球符文代替消耗
再后面学到了 C，又变得更强

技能在一开始设计的时候就设计最强的状态，给玩家用的是加了很多个限制条件的版本
重复学习的过程就是解开各个限制的过程，这个学习顺序可以随意调换，就是各个锁先后解开的区别而已
这样一个主动技能就可以拆成很多个技能书，玩家玩到的时候获取技能书的顺序不同，玩到的感觉也不一样

在这个基础上换皮就高效多了（）
小火球，大火球，巨大火球，只要最终版本的差别大一些，基础版本相似也没关系，
玩家会在变强的过程中使用喜欢的那一种，而且可能后面小火球还比巨大火球更强，再又随着游戏进展而变化

代码会不会很复杂（）
代码真的很复杂（）
至少数值很难设计

想出来的代码实现方案：
最开始设计基础版本
然后设计 n 个它的解锁后的加成
玩家身上存储这个技能的解锁情况
玩家身上存储这个技能解锁之后的汇总详细参数

比如小火球 ABC
开始设计一个小火球，id=little_fire
设计它的基础版本，P_skill["little_fire"]
这里设计了最基础的限制条件，属性补正，索敌逻辑等等（这里可以全填 0）
然后设计小火球 A 解锁加成，id=little_fire_A
base_skill["little_fire_A"]
这里设计了，限制条件需要 1 蓝，基于灵魂属性的属性补正，索敌逻辑是中距离敌人造成伤害
以此类推设计火球 B 和火球 C

然后玩家获得了火球 A 的时候
先检测玩家有无火球，当前是无，所以获取基础版本
然后读取 A 的加成参数，在基础版本上叠加这些参数
这样玩家就拥有了一个基础+A 的技能，呈现出来的效果就是火球 A
当玩家获得火球 B 的时候
读取玩家有无火球，当前有，跳过基础版本获取
然后读取 B 的加成参数，在目前的数据上叠加 B 的参数
这样就得到了 AB 火球

ABC 的获取顺序轮换都行
